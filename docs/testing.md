# Testing

Modified: 2024-01

> Note: This testing setup is experimental and subject to change. If you have any suggestions for improvements to the testing environments please create an issue.

## Unit Test Environment

This project uses a combination of `gtest` and `gmock` to achieve granular unittest coverage and functional verification. The unittest environment is seperate from the main firmware project because cmake enforces a project is 1-1 with a specific toolchain. Furthermore it allows us to reduce build system complexity and provide more flexibility for streamlining for cross-compiling.

You will need `gcc` and `g++` to compile the tests. On Windows you can obtain `gcc` from the `mingw` project. On OSX `gcc` can be installed from `homebrew`. OSX users may be required to perform some [additional steps](#note-on-llvm-clang).

You can configure the unittest project from the project root:
```bash
mkdir tests/build
cmake -B tests/build -S tests/unittests -DCMAKE_BUILD_TYPE=Debug
make -C tests/build -j
```

Run the unittest binaries (uses `ctest` under the hood):
```bash
make -C tests/ test

Running tests...
Test project /Users/christiansargusingh/Projects/dronectl/raptor/tests/build
    Start 1: test_hsm
1/2 Test #1: test_hsm .........................   Passed    0.04 sec
    Start 2: test_sysreg
2/2 Test #2: test_sysreg ......................   Passed    0.01 sec

100% tests passed, 0 tests failed out of 2

Total Test time (real) =   0.06 sec
```

Run the coverage report powered by `gcovr`:
```bash
make -C tests/build coverage
```
You should get a report generated in stdout and an accompanying xml file named `coverage.xml`:
```bash
[100%] Running gcovr to produce Cobertura code coverage report.
Test project /Users/christiansargusingh/Projects/dronectl/raptor/tests/build
    Start 1: test_hsm
1/2 Test #1: test_hsm .........................   Passed    0.04 sec
    Start 2: test_sysreg
2/2 Test #2: test_sysreg ......................   Passed    0.02 sec

100% tests passed, 0 tests failed out of 2

Total Test time (real) =   0.06 sec
(INFO) Reading coverage data...
(INFO) Writing coverage report...
------------------------------------------------------------------------------
                           GCC Code Coverage Report
Directory: ../..
------------------------------------------------------------------------------
File                                    Branches   Taken  Cover   Missing
------------------------------------------------------------------------------
src/common/sysreg.c                           94      57    60%   201,204,211,214,223,225,226,229,230,233,234,237,238,254,274,301,305,315,319,323,325,335,339,349,353,357,359,369,373,383,387,391,393,403,407,417,421
src/os/hsm.c                                  67      16    23%   135,142,146,155,177,209,252,268,285,306,324,327,328,330,340,341,351,352,364,369,371,383,384,398,415,416,420,429,433
------------------------------------------------------------------------------
TOTAL                                        161      73    45%
------------------------------------------------------------------------------
Cobertura code coverage report saved in coverage.xml.
[100%] Built target coverage
```

The coverage target will generate a `coverage.xml` artefact in the cmake build directory. This artefact can be digested by a code coverage gutter tool such as `ryanluker.vscode-coverage-gutters` to view code coverage inside VSCode. Apply the `coverage-gutters` settings provided inside [`utils/vscode/settings.json`](/utils/vscode/settings.json) to your local `settings.json`.

![img](/docs/img/coverage.png)

### Note on LLVM Clang
For MacOS users, you must install and use a gcc toolchain in order to build the unittests. The firmware contains some gcc specific attributes and directives which will cause compile errors on LLVM based compilers such as clang. An example of this is using the section attribute:
```c
__attribute__((section(".ram_d3"))) static StaticTask_t scpi_task_buffer;
```
To avoid clutter in the firmware for supporting multiple compilers I opted to restrict the scope of the unittests to just gcc based compilers.

To compile and run the unittests with coverage you need to point cmake to use the correct c and cxx compilers. For example, if my gcc compilers are located in `/opt/homebrew/bin` I can configure the cmake project using the following cmake options:
```bash
-DCMAKE_C_COMPILER=/opt/homebrew/bin/gcc-14 -DCMAKE_CXX_COMPILER=/opt/homebrew/bin/g++-14
```

Coverage will also not work unless you also specify the GCOV binary. This is because by default on MacOS, the `gcov` executable points to an llvm-based gcov which will not work for coverage symbols generated by the gcc linker. To solve this I have provided the optional `RAPTOR_COVERAGE_GCOV` variable for pointing to the gcc-based `gcov` binary. For example if my gcc-based gcov is discoverable by invoking `gcov-14` I can add the following to the cmake configure step:
```bash
-DRAPTOR_COVERAGE_GCOV=gcov-14
```

## Boostrapping Sandboxing Environments (Deprecated)
In order to test a combination of hardware, STM32 configuration and C modules outside the context of an RTOS, it is recommended to build a sandbox environment for developing a working demo.

Most developers will start from a STM32 Cube project and develop experimental firmware from there. The issue with this approach is these projects contain too much overhead and do not integrate well into our pre-existing toolchain. The goal is to reduce complexity by condensing the surrounding code configuration to a few critical files and integrate it into our cmake build process. This effectively involves building a small bootstrap framework for configuration heavy libraries like the STM32 HAL Library.

This repository contains a `tests` cmake subdirectory which hosts all the raptor test environments. Each folder in the `tests` directory hosts the build configuration, test code and the minimum bootstrap code required to enable its operation. These binaries can be flashed to the board and debugged directly making it easy to:
 1. Test C modules directly from the raptor source firmware
 2. Develop experimental source code in a well encapsulated sandbox environment

## Creating a Test Environment
To create a new test environment create a new folder under `tests`. You can copy the required files and configuration from [bme280](/tests/bme280) and make any neccessary modifications.

Edit `main.c` and `stm32h7xx_hal_conf.h` to configure the required peripherals and HAL modules. Add your test code to `main.c:main`. Here you can write your experimental code in the same `main.c` file or in another local source file or reference a source file in the raptor firmware. 

In any case ensure the correct source and header files are specified in the CMakeLists.txt file. In the cmake code snippets I will use the `bme280` test folder as reference. Note you will likely require `STM32CUBEH7_HAL_SRC` and `STM32CUBEH7_HAL_INCLUDE` for any code using the HAL library:
```cmake
add_executable(
    test 
    ${STM32CUBEH7_HAL_SRC}
    ${CMAKE_SOURCE_DIR}/src/drivers/bme280.c
    startup_stm32h723zgtx.s
    main.c
)
target_include_directories(
    test
    PRIVATE ${STM32CUBEH7_HAL_INCLUDE}
    PRIVATE ${CMAKE_SOURCE_DIR}/include
    PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}
)
```

Include any compile and linker flags for your test binary. You will most likely require `$GCC_FLAGS` `$STM32H723_COMPILE_FLAGS` and `$LINKER_SCRIPT` as defined by the parent scope:
```cmake
target_compile_options(
    test
    PRIVATE ${GCC_FLAGS} ${STM32H723_COMPILE_FLAGS}
    PRIVATE -O0 -g
)
target_link_options(
    test
    PRIVATE ${STM32H723_COMPILE_FLAGS}
    PRIVATE -T${LINKER_SCRIPT} -Wl,--print-memory-usage -Wl,--gc-sections -static -z muldefs -Wl,-Map=${CMAKE_PROJECT_NAME}.map -Wl,--start-group -lc -lm -Wl,--end-group
)
```

Finally add the new subdirectory to the `tests` CMakeLists.txt:
```cmake
enable_testing()
# Include and add each test subdirectory
...
add_subdirectory(bme280)
```

## Building Test Binaries
Test binaries under the `tests` subdirectory can be built using the `BUILD_TESTS` option. Note that the cmake project must be reconfigured:
```bash
cmake .. -DCMAKE_BUILD_TYPE=Debug -DBUILD_TESTS=On
```

The tests will now be compiled alongside the raptor source code:
```bash
make -j
```